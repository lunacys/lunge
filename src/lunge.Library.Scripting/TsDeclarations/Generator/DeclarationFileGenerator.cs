using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using lunge.Library.Scripting.TsDeclarations.Generator.TsMembers;

namespace lunge.Library.Scripting.TsDeclarations.Generator;

public class DeclarationFileGenerator
{
    public List<TsType> Types { get; }
    public List<TsVariable> Variables { get; }
    public List<string> Warnings { get; }

    private readonly HashSet<string> _savedTypeNames;

    public DeclarationFileGenerator()
    {
        Types = new List<TsType>();
        Variables = new List<TsVariable>();
        Warnings = new List<string>();

        _savedTypeNames = new HashSet<string>();
    }

    public void Register(object obj, string? name = null)
    {
        if (obj is Type type)
        {
            Register(type);
        }
        else
        {
            // TODO: Will work incorrectly if an object is added before the type
            var tsType = Types.Find(t =>
                name == null
                    ? t.PublicName == t.TypeWrapped.Type.Name
                    : t.PublicName == name
            );

            Variables.Add(new TsVariable(
                    this,
                    name,
                    obj,
                    tsType
                )
            );
        }
    }

    public void Register(Type type)
    {
        var tsType = new TsType(type, this);
        Types.Add(tsType);

        _savedTypeNames.Add(tsType.PublicName);
    }

    public string Generate()
    {
        var sb = new StringBuilder("/* eslint-disable */\n\n");

        sb.AppendLine($" // GENERATED BY A TOOL AT {DateTime.UtcNow} UTC\n");
        sb.AppendLine(" // Types \n");
        foreach (var tsType in Types)
        {
            sb.AppendLine(tsType.ToString());
        }

        sb.AppendLine("\n // Variables \n");
        foreach (var tsVariable in Variables)
        {
            sb.AppendLine(tsVariable.ToString());
        }

        return sb.ToString();
    }

    internal string SolveType(Type type)
    {
        var ex = Types.Find(t => t.TypeWrapped.Type.Name == type.Name);
        if (ex != null)
            return ex.PublicName;

        if (type.IsGenericType)
        {
            var generics = type.GetGenericArguments();
            var name = GeneratorUtils.RemoveGenerics(type.Name);

            // TODO: Arrays instead of lists may work incorrectly
            if (name == "List" || name == "IEnumerable")
            {
                var val = generics.First();
                return $"{SolveType(val)}[]";
            }
            if (name == "Nullable")
            {
                var val = generics.First();
                return $"{SolveType(val)} | null";
            }

            if (name == "ValueTuple")
            {
                return $"[{type.GetDeclGenericsAsString(false, SolveType)}]";
            }
            if (name == "EventHandler")
            {
                var val = generics.First();

                return GeneratorUtils.GetGenericParamsForEventHandler(
                    type,
                    "any",
                    SolveType
                );
            }

            if (name == "Action")
            {
                return GeneratorUtils.GetGenericParamsForAction(type, SolveType);
            }

            if (name == "Func")
            {
                return GeneratorUtils.GetGenericParamsForFunc(type, SolveType);
            }

            return $"{name}{type.GetDeclGenericsAsString()}";
        }

        if (type.Name == "EventHandler")
        {
            return GeneratorUtils.GetGenericParamsForEventHandler(null, "any", SolveType);
        }

        return GeneratorUtils.CSharpTypeToTS(type.Name);
    }

    internal string[] SolveParameters(ParameterInfo[] parameterInfo)
    {
        var result = new string[parameterInfo.Length];

        for (int i = 0; i < parameterInfo.Length; i++)
        {
            var p = parameterInfo[i];
            var name = p.Name;
            var type = SolveType(p.ParameterType);

            result[i] = $"{name}: {type}";
        }

        return result;
    }

    internal void AddWarning(string msg)
    {
        Warnings.Add(msg);
    }

    public override string ToString() => Generate();
}